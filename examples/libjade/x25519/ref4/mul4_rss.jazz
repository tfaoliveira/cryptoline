inline fn __reduce4(reg u64[8] z) -> reg u64[4]
{
  reg u64 z8 r0 r38 rax h l;
  reg u64[4] r;
  reg bool cf;
  inline int i;

  r38 = 38;

	rax = z[4];
	h, l = rax * r38;
	r[0] = l;
	r[1] = h;

	rax = z[5];
	h, l = rax * r38;
	cf, r[1] += l;

  r[2] = #MOV(0);
	rax = z[6];
	_, r[2] += h + cf;
	h, l = rax * r38;
	cf, r[2] += l;

	r[3] = #MOV(0);
	rax = z[7];
	_, r[3] += h + cf;
	h, l = rax * r38;
	cf, r[3] += l;

	z8 = #MOV(0);
	_, z8  += h + cf;

	cf, r[0] += z[0];

  for i = 1 to 4 {
  	cf, r[i] += z[i] + cf;
	}

	_, z8 += 0 + cf;
	z8 *= 38;

  r0 = #MOV(0);

  cf, r[0] += z8;
  for i = 1 to 4 {
	    cf, r[i] += r0 + cf;
  }

	_, r0 += r0 + cf;

	r0 *= 38;
	r[0] += r0;

  return r;
}

inline fn __mul4_rss(stack u64[4] xa ya) -> reg u64[4]
{
  reg u64[8] z;
  reg u64[4] r x y;
  reg u64 h l hprev;
  reg bool cf;
  inline int i j;

  for i = 2 to 8 { z[i] = #MOV(0); }

  x[0] = xa[0];
  for j = 0 to 4 {
    y[j] = ya[j];
    h, l = y[j] * x[0];
    if (j == 0) {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      _, z[j + 1] += h + cf;
    }
  }

  for i = 1 to 4 {
    x[i] = xa[i];
    for j = 0 to 4 {
      y[j] = ya[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if (j == 0) {
        hprev = #MOV(0);
        _, hprev += h + cf;
      } else {
        _, h += 0 + cf;
        cf, z[i+j] += hprev;
        if (1 <= j && j < 4 - 1) {
          hprev = #MOV(0);
          _, hprev += h + cf;
        } else { /* j = 4 */
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  r = __reduce4(z);

  return r;
}

export fn mul4_rss(reg u64 rp fp gp)
{
  inline int i;
  reg u64[4] r f g;
  stack u64[4] fs gs;
  stack u64 rps;

  rps = rp;
  for i=0 to 4
  { f[i] = [fp + 8*i];
    g[i] = [gp + 8*i];
  }

  fs = #copy(f);
  gs = #copy(g);

  r = __mul4_rss(fs, gs);

  rp = rps;
  for i=0 to 4
  { [rp + 8*i] = r[i]; }
}


